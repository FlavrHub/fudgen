package rparser

import (
	"../scheduler"
	"errors"
	"gopkg.in/yaml.v2"
	"regexp"
	"strconv"
	"strings"
)

/*
see recipes/r.yml
*/

type recipe struct {
	Name        string   //name of food/recipe/step
	Operation   string   //name of operation to make this step
	Notes       string   //random notes to keep track of
	Attributes  []string //list of things like quantity or time
	Identifier  int      //unique identifier for this step, autogenerated by parser
	Ingrediants []recipe //if empty then this is raw ingrediant
}

func ParseYaml(input string) (r recipe, err error) {
	err = yaml.Unmarshal([]byte(input), &r)
	id := 0
	var check func(*recipe)
	check = func(R *recipe) {
		id++ //make sure first thing has id=1!
		(*R).Identifier = id
		if len((*R).Ingrediants) == 0 && (*R).Operation != "" {
			err = errors.New("can't have operation description on raw ingrediant")
			return
		}
		if len((*R).Ingrediants) > 0 {
			for k := 0; k < len((*R).Ingrediants); k++ {
				check(&((*R).Ingrediants[k]))
			}
		}
	}
	check(&r)
	return r, err
}

//returns time in seconds!
func getTime(attr []string) int {
	times := map[string]int{
		"m":   60,
		"min": 60,
		"hr":  3600,
		"s":   1,
		"sec": 1}

	re, err := regexp.Compile(`[\d]+`)
	if err != nil {
		panic(err) //will never happen
	}

	for _, s := range attr {
		for k, v := range times {
			if strings.Index(s, k) != -1 {
				n := re.FindString(s)
				if n != "" {
					t, err := strconv.Atoi(n)
					if err != nil {
						panic(err)
					}
					return t * v
				}
			}
		}
	}
	return 0
}

type steps map[int]int   //recipe identifier ---> time
type depedencies [][]int //array of tuples for edges step1 ---> step2

/*
returns schedule of recipe work
for n workers
*/
func ScheduleSteps(r *recipe, n int) [][]schedular.WorkerHistory {
	steps := map[int]int{}
	depedencies := [][]int{}
	var foo func(r *recipe)
	foo = func(r *recipe) {
		steps[(*r).Identifier] = getTime((*r).Attributes)
		for i := 0; i < len((*r).Ingrediants); i++ {
			depedencies = append(depedencies, []int{(*r).Ingrediants[i].Identifier, (*r).Identifier})
			foo(&((*r).Ingrediants[i]))
		}
	}
	foo(r)
	return schedular.Schedule(steps, depedencies, n)
}

/*
returns dependencies for recipe
keys: id of step
value: id's of prereqs
*/
func GetDependencies(r *recipe) (d [][]int) {
	var foo func(r *recipe)
	foo = func(r *recipe) {
		for i := 0; i < len((*r).Ingrediants); i++ {
			d = append(d, []int{(*r).Ingrediants[i].Identifier, (*r).Identifier})
			foo(&((*r).Ingrediants[i]))
		}
	}
	foo(r)
	return
}

/*
returns a list of steps for the
recipe. These are all the sub-recipes
in an array. the ingrediants are nil-ed
because they just exist further in the list.
This plus dependencies should be enough to
recover the original structure
*/
func ListSteps(r *recipe) (steps []recipe) {
	var foo func(r *recipe)
	foo = func(r *recipe) {
		a := *r
		a.Ingrediants = nil //no need for recursive structure in list form
		steps = append(steps, a)
		for _, e := range (*r).Ingrediants {
			foo(&e)
		}
	}
	foo(r)
	return
}
